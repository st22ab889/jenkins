#!/usr/bin/env groovy			// 声明式 Jenkinsfile, 也可加入 Shebang line, 但必须放在第一行 
pipeline {
    agent any
	
	// environment、parameters、currentBuild 三种变量可以参考 http://192.168.32.200:8080/pipeline-syntax/globals
	
	parameters {				
		string(name: 'HostName', defaultValue: 'abc.com', description:'input your host name')
		booleanParam(name: 'IsPatch', defaultValue: true, description: 'patch or not')
		choice(name: 'PatchVersion', choices:['1.21.002','1.22.005', '1.23.333'])
		password(name: 'Pwd', defaultValue:'', description: 'input your login password')
		text(name: 'Notes', defaultValue: 'no more info', description:'input your note')
		// 还支持其它三种类型参数: 凭据参数、文件参数、运行时参数
	}
	
	environment {				// 全局变量, environment 是声明式Pipeline的语法结构,必须写在"pipeline {}"或"stage {}"内部, 变量自动纳入 env 上下文
		APP_NAME = 'my-app'
		DB_PASSWORD = credentials('8796888d-c23e-4e59-aab0-8251bccb816f')	// 引用凭据(自动注入为安全变量)
	}	
		
    stages {
        stage('First') { 
		
			environment {										// 阶段内局部变量
                BUILD_VERSION = '1.0.0'		
            }
		
            steps {
                echo "应用名: ${APP_NAME}" 				
                echo "版本: ${BUILD_VERSION}"
				
				echo "版本: ${env.APP_NAME}"		   
				echo "版本: ${env.BUILD_VERSION}"
            }
        }
		
		stage('Second') { 
			steps {
				
				script {										// script 只能放在 steps {} 中
					env.MYTOOL_VERSION = '1.33'					// 这种方式设定全局变量只能放在 script {} 中, 当前stage和之后的stage才能引用到这里的变量, 有顺序
				}
				
				sh 'echo my tool version is $MYTOOL_VERSION'	// shell 中引用环境变量
				echo "my tool version is ${MYTOOL_VERSION}" 	// Pipeline语法中引用环境变量,如果是字符串插值需用${MYTOOL_VERSION}或${env.MYTOOL_VERSION},且只能加双引号
				echo "my tool version is ${env.MYTOOL_VERSION}"
				echo env.MYTOOL_VERSION							// Pipeline语法中引用环境变量,如果不是字符串插值,可以直接 env.MYTOOL_VERSION  

			}
        }
		
        stage('Third') { 
            steps {
				// withEnv() 代码块 定义的变量仅在块内部生效,相当于临时变量
				withEnv(['TEMP_DIR=/tmp/build', "LOG_LEVEL=${env.DEBUG ? 'debug' : 'info'}"]) {		
					echo "临时目录: ${TEMP_DIR}" 
					sh 'echo "日志级别: $LOG_LEVEL"'
				}
                // echo "临时目录: ${TEMP_DIR}"  				// withEnv块外无法访问, pipeline 报异常,最终失败
            }
        }
		
		stage('fourth'){
			
			when{
				expression { params.IsPatch }
			}
			
			steps {
				sh 'echo Hostname is $HostName'					// 说明 parameter 参数也会引入到系统的环境变量
				echo "host name is ${params.HostName}"			// 使用 pipeline echo 步骤, 要在字符串中引用变量, 要用双引号 	
				echo params.Notes
				script {
					if(params.IsPatch){
						echo "Patch level is ${params.PatchVersion}"
					}else{
						echo "info is ${params.Notes}"
					}
				}
			}
		}
		
		stage('fifth'){
			steps {
				// sh 'echo Full project name is $fullProjectName'				// 不能打印出变量,说明 currentBuild 的变量没有注入到系统环境变量中
				echo "Full project name is ${currentBuild.fullProjectName}"
				echo currentBuild.fullProjectName
			}
		}
		
		stage('sixth'){
			/*
			// tools 块可以配置在 pipeline块中 和 stage块中, 区别是作用域不一样
			tools {
				// 'M3'是Jenkins"全局工具配置" 中maven配置的名称. 配置后有手动安装和自动安装.如果是自动安装,当流水线在某个节点运行时,发现没有该工具会自动安装
				maven 'M3'
			}
			
			environment{
				PATH = "${tool 'M3'}/bin:${env.PATH}"		// 将Maven的bin目录添加到节点的PATH中
			}
			*/
			steps {
				// sh 'mvn --version'  						// 可以直接使用mvn命令
				sh 'echo $PATH'
				sh 'printenv' 
			}	
		}
		
		stage('seventh'){
			environment{
				CC = """${sh(								// 动态设置环境变量
						returnStdout:true,
						script: 'echo "clang"'	
					)}""".trim()							// 使用 returnStdout 时，返回的字符串末尾会追加一个空格。可以使用 .trim() 将其移除
				
				EXIT_STATUS = """${sh(
						returnStatus:true,
						script:'exit 1'
					)}"""
			}
			steps{
				echo "CC: ${env.CC}"		 
				echo "status: ${EXIT_STATUS}"
			}
		}
    }
}



==================================================================================================================================

定义 parameter 参数的四种方式：
1. 在 Jenkinsfile 中用代码定义, 这种方式定义完成后运行一次pipeline, 才会出现"Build with Parameters" 按钮
2. 每条pipeline都有一个配置选项, 在里面勾选"参数化构建过程",然后手动填入.
3. 如果启用了 api 触发pipeline, 可以在api的url中传参


===================================================================================================================================

### 核心区别总结
| 维度               | `environment` 块                  | `env.` 直接赋值                  | `withEnv()` 函数                  |
|--------------------|-----------------------------------|-----------------------------------|-----------------------------------|
| 适用类型           | 仅声明式 Pipeline                 | 脚本式 + 声明式 `script` 块       | 所有类型 Pipeline                 |
| 作用域             | 全局（根节点）或局部（stage内）   | 全局（`env` 是全局对象）          | 仅在代码块内部（临时）            |
| 凭据支持           | 直接通过 `credentials()` 引用     | 不支持，需配合 `withCredentials`  | 不支持，需配合 `withCredentials`  |
| 灵活性             | 静态定义为主，支持简单表达式      | 支持动态逻辑（条件、计算等）      | 支持变量拼接，仅临时生效          |
| 典型用途           | 定义全局/阶段固定变量、引用凭据   | 动态生成变量、全局共享变量        | 临时变量、局部代码块专用变量      |


### 访问方式

- **都遵守以下规则**：
  - shell中引用变量使用 $变量
  - pipeline中字符串插值引用, 使用 ${变量} 或 ${env.变量},并且只能用双引号. 例如: echo "临时目录: ${TEMP_DIR}" 
  - pipeline中不是字符串插值引用, 直接 env.变量,不要任何引号.例如: def a = env.变量  或  echo env.变量

### 最佳实践
- 声明式 Pipeline 中，优先用 `environment` 块定义全局/阶段变量，尤其是需要引用凭据时。
- 需要动态逻辑（如条件赋值、计算）时，用 `env.` 在 `script` 块中定义。
- 两种方式定义的变量最终都可以通过 `${变量名}` 或 `env.变量名` 访问（本质上都属于 `env` 上下文）
- 仅需在某段代码中临时使用的变量，用 `withEnv()`，避免全局污染。


===================================================================================================================================


Jenkins 的全局工具配置不仅包含默认提供的工具类型（如 JDK、Maven、Gradle 等），还支持通过插件扩展自定义工具类型，也可以直接在现有框架下配置自定义工具路径。

### 主要方式如下：

1. **利用现有工具框架配置自定义工具**  
   即使是 Jenkins 未默认列出的工具，也可以通过「手动指定路径」的方式在全局工具配置中管理：  
   - 进入「系统管理 → 全局工具配置」  
   - 找到任意一种工具类型（如「Maven」），点击「新增 Maven」  
   - 取消勾选「自动安装」，填写自定义名称（如「MyCustomTool」），并在下方节点配置中手动指定路径  

   这种方式本质是「借用」现有工具类型的配置框架，适合快速管理简单的自定义工具。

2. **通过插件扩展工具类型**  
   许多插件会为特定工具添加专门的配置入口，例如：  
   - NodeJS 插件：添加 NodeJS 版本管理  
   - Docker 插件：添加 Docker 版本配置  
   - Python 插件：添加 Python 环境管理  

   安装对应插件后，全局工具配置中会出现新的工具类型，支持自动安装或手动配置。

3. **使用「Custom Tools Plugin」插件**  
   这是最灵活的方式，专门用于管理自定义工具：  
   1. 安装插件：「系统管理 → 插件管理」中搜索并安装「Custom Tools Plugin」  
   2. 配置工具：在全局工具配置中会出现「Custom Tools」选项，点击「新增」  
   3. 填写工具名称、描述，并配置安装方式（自动下载、手动路径等）  

   配置后，即可在 Pipeline 中通过 `${tool '自定义工具名'}` 引用。

### 在 Pipeline 中使用自定义工具：
无论通过哪种方式配置，引用方法与系统默认工具一致：
```groovy
pipeline {
    agent any
    environment {
        // 引用自定义工具路径
        CUSTOM_TOOL_PATH = "${tool 'MyCustomTool'}"
        PATH = "${CUSTOM_TOOL_PATH}/bin:${env.PATH}"
    }
    stages {
        stage('Test') {
            steps {
                sh '自定义工具命令 --version'
            }
        }
    }
}
```

总结：Jenkins 全局工具配置支持高度自定义，通过插件或手动配置可以管理几乎所有类型的工具，无需局限于默认提供的类型。

===================================================================================================================================







