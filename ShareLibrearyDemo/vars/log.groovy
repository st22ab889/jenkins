
/*
* vars 是 Jenkins 共享库的一个特殊目录，用于存放"全局变量"脚本,放在这里的脚本会被 Jenkins 特殊处理。
* 在 Jenkins 内部,当流水线需要使用vars目录下的脚本中的方法时,Jenkins会创建该脚本的一个实例,并且整个流水线执行过程中只会创建一次. 由于是单例实例,可以在一个 .groovy 文件中定义多个相关方法
* 这种脚本中的方法可以直接在 Pipeline 中通过脚本名调用
*/

/*
* Jenkins 的"全局变量参考"页面(Pipeline Syntax → Global Variables Reference)会列出可用的全局变量(包括共享库中定义的).但共享库中的变量不会在 Jenkins 刚加载库时就显示在这里，必须满足两个条件：
*	1.Jenkins 已经加载了该共享库.
*	2.至少有一个使用该库的流水线成功运行过之后,这些变量才会被 Jenkins 识别并展示在参考页面中,方便用户查看和使用.
*/



def info(message){
	echo "INFO: ${message}"
}

def warning(message) {
	echo "WARNING: ${message}"
}



/*
* 避免在全局变量中保存状态, 共享库中定义的所有全局变量都应该是无状态的，即它们应仅作为函数的集合. 保存状态应该改用静态类，或者实例化一个类的局部变量:
* 共享库的全局变量(如 vars 目录下的脚本)在 Jenkins 中是单例模式，即整个 Jenkins 实例中只有一个实例。如果在其中存储状态，会导致:
*	1.跨流水线污染:多个流水线同时运行时，可能修改同一个全局变量的状态，导致逻辑混乱
*   2.状态残留:一个流水线运行结束后，全局变量的状态不会自动重置，可能影响后续流水线(比如前一次运行的错误值被下一次读取)
*	3.即使忽略多流水线冲突和状态残留，想用全局变量临时保存状态，jenkins控制器重启(进程重启)会让这种状态彻底丢失
*/


/* 
* 不建议使用字段作为全局变量，但可以定义字段并将其用作只读, "@groovy.transform.Field"作用是:
*	1.改变变量的作用域: 
*		在普通 Groovy 脚本中，直接定义的变量(如 def yourField = "value")本质上是脚本内部的局部变量，作用域仅限于脚本执行期间，且不会被视为脚本对象的成员。
*		加上 @Field 注解后，变量会成为脚本对象的实例字段，可以被脚本中的所有方法访问，且在脚本对象的生命周期内保持存在。
*	2.在 Jenkins 共享库中的特殊意义: 在 Jenkins 共享库的 vars 目录下的脚本中(这些脚本会被处理为单例对象)，@Field 注解能让变量成为全局可访问的字段：
*		脚本中的所有方法都能访问该变量； 
*		当流水线调用该脚本的方法时，变量的状态会在多次方法调用间保持(直到 Jenkins 重启或脚本重新加载)
*   3.注意事项
*       @Field 注解的变量在 Jenkins 共享库中属于单例对象的字段，多流水线共享同一个变量，可能导致状态冲突(如多个流水线同时修改 counter),需谨慎使用
*		官方建议尽量避免用这种方式保存状态（除非明确需要跨方法共享临时数据），以免引发不可控的并发问题
*   4.总结: @groovy.transform.Field 的核心作用是将脚本中的变量提升为字段，使其能被脚本内的所有方法访问，这在 Jenkins 共享库中是实现跨方法数据共享的常用方式，但需注意并发风险
*/


@groovy.transform.Field
def version = "v12.23.26"

def printVersion() {
	echo version			// 如果 version 变量没有加 Field 注解, 报错：No such property: counter for class: myVar
}

